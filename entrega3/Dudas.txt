Preguntas Resueltas del 2014.

En el diagrama:
		|    argn    |	fp+4*(n+1)
		|    ...     |
		|    arg2    |	fp+16
		|    arg1    |	fp+12
		|	fp level |  fp+8
		|  retorno   |	fp+4
		|   fp ant   |	fp
		--------------	fp
		|   local1   |	fp-4
		|   local2   |	fp-8
		|    ...     |
		|   localn   |	fp-4*n

1) el "fp level", es el SL? Si, El SL es el frame de la función que le corresponde a la llamada (la que
la anida). El fp ant. es el fp de la función que hace el call.

Definición de SL:
El SL de la función g es el FP de la función f, siendo f la que define a g, es decir
   let f() =
       let g()= ...
Notar que la función anidante (función donde se define la función llamada) no necesariamente es igual que la función llamante (función donde se llama a la función llamada)

2) el fp se refiere al frame actual? Sí.
3) que es local? las var. locales.

4) Cuando se crea un nuevo nivel? Cuando se declara una funcion.
5) El código intermedio de una declaración de variable, equivale a la asignación de la var. recien creada, con su valor inicial? Si.

7) En la declaración de una función, tengo que usar el código intermedio del body
de cada función? Si.


--------------------------------------------------------------------------------
Dudas 2016

- En la entrega1 _tigermain tiene el resultado de tipo TInt, mientras que la entrega2 _tigermain tiene el de resultado de tipo TUnit, así esta bien?
Si está bien, ¿Cómo se probaría la segunda entrega si los tipos de los tests están como para que funcionen con TInt?

- ¿Cual es la sugerencia de Guillermo para modificar el tigerframe?

- ¿Para qué la canonización elimina los ESEQ?


----- Para preguntar en clase ------

- ¿Cómo se usa el intérprete que está en tigerinterp.sml?. Resuelto.

- Una vez terminado el maximal munch ¿Cuáles son los pasos a seguir?. Preguntado.

- Te escribo por estoy avanzando con el compilador junto con Joel Catacora y nos surgió una duda respecto a la arquitectura destino. Estamos entre 2 opciones:
  - ARM
  - i386
  Queremos saber qué "problemas" puede presentarnos ARM, que no están, o son más simples, en i386? Preguntado.

- En el maximal munch de un jump "simple", ¿siempre tenemos un label como expresión?.

--------------------------------------------------------------------------------
Dudas RESUELTAS 2017

- En la variable "datosGlobs", cuando se agrega el PROC de una función f, asociamos como frame de f, 
el frame que viene del level, el cual se crea con el nombre de f más un prefijo formado por una string obtenida de tigertemp.newLabel(). ¿Está bien?.
El prefijo nos estorba para usar el intérprete, debido a que busca el frame por el nombre de las funciones sin tener en cuenta el prefijo ¿como lo solucionamos, si mantenemos este prefijo?.

- En el código intermedio del CALL f, ¿deberíamos incluir MOVEs de los valores con los que se llama f, a los registros o
direcciones de memoria, que genera allocArg(), en la declaración de f?. El interpete lo hace solo, si incluimos la función
"formals" y hacemos MOVEs en el preambulo de la función, en procEntryExit1.

- ¿Qué pasa cuando no esté el intérprete?. ¿El trabajo lo hace la instrucción CALL de ARM?. -----> NO

- ¿Como es la estructura del frame de ARM Cortex-A8?. ¿Utilizamos un registro especial para el static link, o lo mantenemos en memoria?. -----> EN MEMORIA

- En ARM, ¿La dirección de retorno se guarda en el registro lr?. -----> Si se implementa con BL, SI

- ¿Por qué es necesario guardar en un registro el valor de retorno (RV) luego del CALL? Ésto lo vimos del código de Felipe. -----> Respondida por Guillermo




Dudas no resueltas 2017

- En el chequeo de tipos, ¿deberiamos capturar la excepción Ciclo, y mostrar un error más detallado?.

- ¿Esta bien mantener dos levels donde el nombre del frame sea "_tigermain", en la pila de levels (uno viene por defecto, al crear la pila)?.

- ¿Podemos definir en tiger una función de nombre "_tigermain"?.

- A nosotros no nos importa el orden con el cual se declaran los miembros de un record, está bien?. Según la pág. 518 del libro, SI importa.

- ¿Por qué la alocación de un record en memoria ocurre en el orden inverso al declarado? (No hay problema al recorrerlo, sólo nos llama la atención
  que se haga todo en orden inverso)



Selección de instrucciones
--------------------------

- ¿Esta bien que en la selección de instrucciones, caso del CALL, se ponga como jump a SOME [name] mientras que en el libro se recomienda poner NONE?

- En el caso "EXP e" de munchStm consideramos que la instrucción generada es vacia (el campo assem = ""), ¿Está bien? ¿Es necesario este caso?

- Consideramos que aquellos MOVEs con igual source ("assem = mov 's0, 's1\n", donde s0 = s1), pueden ignorarse, al ser reduntantes, ¿está bien?. 

- ¿Es correcto utilizar push para poner los argumentos de la función llamada en memoria?

- Cuando se hace la selección de instrucciones del CALL, el libro recomiendo hacer una función auxiliar munchArgs, que genere el código encargado de mover 
los argumentos a donde correspondan (registro, o memoria). 
Sabemos que del quinto argumento, en adelante, los argumentos van a memoria, ¿esto lo hacemos mediante PUSHs?.
Luego de la instrucción BL (asociada al CALL), ¿deberían estar los POPs correspodientes?

Codigo intermedio:
CALL (f, a0,a1,a2,a3,a4,a5) 

Código ARM:
..
(movimientos de los argumentos a los registros r0-r3)
PUSH {a4, a5}
BL f
POP {a4, a5}
..

- En procEntryExit1 agregamos como preludio y epilogo al cuerpo de la función, el código intermedio correspondiente a guardar y restaurar los registros callee saves.
Esto lo hicimos con MOVEs a temporarios frescos.
Ejemplo: 
Si r4 y r5 son todos los callee saves, entonces nos queda un código intermedio de la forma
PROLOGO @ BODY @ EPILOGO
Donde, PROLOGO contiene: MOVE(t0, r4) ; MOVE(t1, r5)
EPILOGO contiene: MOVE(r4, t0); MOVE (r5, t1)

Así está bien?.
O deberiamos implementarlo con instrucciones que los guarden a memoria (haciendo pushs o pops de "alto nivel")?


- Implementamos el munch del CALL, mas o menos así:
munchStm (CALL (NAME f) xs) = 
  emit (A.OPER { assem = "bl " ^ f ^ "\n",
                 src = muchArgs,
                 dst = calldefs,
                 jump = SOME [f]}) 
  ; makePops(temporaries)
Donde "makePops" hace los emits de las operaciones correspondientes a la instrucción pop,
según la lista de temporarios a los que se les hizo push.

¿Así esta bien?. Solo pudimos agregar los pops de esta forma.

Como esta forma no nos convencia. 
Pensamos que quizas habría una forma de patear el problema de generar el código de los pushs y pop
de los argumentos que van a memoria, para más adelante, en el coloreo (como se hace con los MOVEs a
temporarios frescos de los registros calle saves, en procEntryExit1).

- Si r5 y LR con todos los registros calle saves, ¿podemos usar cualquiera de estas dos formas
para retornar a la próxima intrucción de la función llamante?.

  ...
  BL function1
  ...


function1 (Opción 1)
  PUSH  {R5,LR}
  ...
  POP {R5,PC}

function1 (Opción 2)
  PUSH  {R5,LR}
  ...
  POP {R5,LR}
  BX  LR

- ¿Como deberíamos implementar procEntryExit2?. A que se refiere con: "indica al register allocator que ciertos registros se mantienen vivos 
en la salida de la función".

---------------------------------------------------------------------------------

LO ÚLTIMO:
- Probar un ejemplo en la máquina virtualizada.

LO HECHO:
- Funciona el intérprete agregandole el prefijo a los labels de funciones.
- Modificamos el interprete para que respete el allocArray de C.
- Arreglado el almacenamiento de strings en el interprete.
- Modificamos getstrFun para que tome de a un char (antes tomaba toda una línea y por esto no funcionaba el ejemplo del merge).
- Testeado el array.
- Seteado correctamente los registros fv, sp, etc.
- Controlamos todos los test usando el intérprete.
- Terminar llamada a función para assembler en tigercodegen.sml.
- Hecho caso para el NAME en munchExp (puede llegar este caso cuando hay una string).
- Hechos los casos de BINOP para las demás operaciones (MINUS, MUL, DIV, etc.).
- Agregar los casos de error para tener los matching completos del munch.
- Terminada función "format" de codegen.sml.
- Arreglar munchArgs. Guardar correctamente los argumentos que van a memoria (usar push).
- Terminar el código que guarda y restaura los callee saves. Arreglar el ejemplo "testMultipleArgs.tig".
- Terminado selección de instruciones.
- Terminado tigergraph.sml


OBSERVACIÓN
- Tener en cuenta que la instrucción "bl" requiere agregar dos instrucciones al término del body de la función a la que se salta.