Dudas resueltas del 2014.

En el diagrama:
		|    argn    |	fp+4*(n+1)
		|    ...     |
		|    arg2    |	fp+16
		|    arg1    |	fp+12
		|	fp level |  fp+8
		|  retorno   |	fp+4
		|   fp ant   |	fp
		--------------	fp
		|   local1   |	fp-4
		|   local2   |	fp-8
		|    ...     |
		|   localn   |	fp-4*n

1) el "fp level", es el SL? Si, El SL es el frame de la función que le corresponde a la llamada (la que
la anida). El fp ant. es el fp de la función que hace el call.

Definición de SL:
El SL de la función g es el FP de la función f, siendo f la que define a g, es decir
   let f() =
       let g()= ...
Notar que la función anidante (función donde se define la función llamada) no necesariamente es igual que la función llamante (función donde se llama a la función llamada)

2) el fp se refiere al frame actual? Sí.
3) que es local? las var. locales.

4) Cuando se crea un nuevo nivel? Cuando se declara una funcion.
5) El código intermedio de una declaración de variable, equivale a la asignación de la var. recien creada, con su valor inicial? Si.

7) En la declaración de una función, tengo que usar el código intermedio del body
de cada función? Si.


--------------------------------------------------------------------------------
Dudas 2016

- En la entrega1 _tigermain tiene el resultado de tipo TInt, mientras que la entrega2 _tigermain tiene el de resultado de tipo TUnit, así esta bien?
Si está bien, ¿Cómo se probaría la segunda entrega si los tipos de los tests están como para que funcionen con TInt?

- ¿Cual es la sugerencia de Guillermo para modificar el tigerframe?

- ¿Para qué la canonización elimina los ESEQ?


----- Para preguntar en clase ------

- ¿Cómo se usa el intérprete que está en tigerinterp.sml?. Resuelto.

- Una vez terminado el maximal munch ¿Cuáles son los pasos a seguir?. Preguntado.

- Te escribo por estoy avanzando con el compilador junto con Joel Catacora y nos surgió una duda respecto a la arquitectura destino. Estamos entre 2 opciones:
  - ARM
  - i386
  Queremos saber qué "problemas" puede presentarnos ARM, que no están, o son más simples, en i386? Preguntado.

- En el maximal munch de un jump "simple", ¿siempre tenemos un label como expresión?.

--------------------------------------------------------------------------------
Dudas RESUELTAS 2017

- En la variable "datosGlobs", cuando se agrega el PROC de una función f, asociamos como frame de f, 
el frame que viene del level, el cual se crea con el nombre de f más un prefijo formado por una string obtenida de tigertemp.newLabel(). ¿Está bien?.
El prefijo nos estorba para usar el intérprete, debido a que busca el frame por el nombre de las funciones sin tener en cuenta el prefijo ¿como lo solucionamos, si mantenemos este prefijo?.

- En el código intermedio del CALL f, ¿deberíamos incluir MOVEs de los valores con los que se llama f, a los registros o
direcciones de memoria, que genera allocArg(), en la declaración de f?. El interpete lo hace solo, si incluimos la función
"formals" y hacemos MOVEs en el preambulo de la función, en procEntryExit1.

- ¿Qué pasa cuando no esté el intérprete?. ¿El trabajo lo hace la instrucción CALL de ARM?. -----> NO

- ¿Como es la estructura del frame de ARM Cortex-A8?. ¿Utilizamos un registro especial para el static link, o lo mantenemos en memoria?. -----> EN MEMORIA

- En ARM, ¿La dirección de retorno se guarda en el registro lr?. -----> Si se implementa con BL, SI

- ¿Por qué es necesario guardar en un registro el valor de retorno (RV) luego del CALL? Ésto lo vimos del código de Felipe. -----> Respondida por Guillermo


Dudas resueltas por Guillermo
-----------------------------

- ¿Es correcto utilizar push para poner los argumentos de la función llamada en memoria?

- Cuando se hace la selección de instrucciones del CALL, el libro recomiendo hacer una función auxiliar munchArgs, que genere el código encargado de mover 
los argumentos a donde correspondan (registro, o memoria). 
Sabemos que del quinto argumento, en adelante, los argumentos van a memoria, ¿esto lo hacemos mediante PUSHs?.
Luego de la instrucción BL (asociada al CALL), ¿deberían estar los POPs correspodientes?

Codigo intermedio:
CALL (f, a0,a1,a2,a3,a4,a5) 

Código ARM:
..
(movimientos de los argumentos a los registros r0-r3)
PUSH {a4, a5}
BL f
POP {a4, a5}
..

- En procEntryExit1 agregamos como preludio y epilogo al cuerpo de la función, el código intermedio correspondiente a guardar y restaurar los registros callee saves.
Esto lo hicimos con MOVEs a temporarios frescos.
Ejemplo: 
Si r4 y r5 son todos los callee saves, entonces nos queda un código intermedio de la forma
PROLOGO @ BODY @ EPILOGO
Donde, PROLOGO contiene: MOVE(t0, r4) ; MOVE(t1, r5)
EPILOGO contiene: MOVE(r4, t0); MOVE (r5, t1)

Así está bien?.
O deberiamos implementarlo con instrucciones que los guarden a memoria (haciendo pushs o pops de "alto nivel")?


- Implementamos el munch del CALL, mas o menos así:
munchStm (CALL (NAME f) xs) = 
  emit (A.OPER { assem = "bl " ^ f ^ "\n",
                 src = muchArgs,
                 dst = calldefs,
                 jump = SOME [f]}) 
  ; makePops(temporaries)
Donde "makePops" hace los emits de las operaciones correspondientes a la instrucción pop,
según la lista de temporarios a los que se les hizo push.

¿Así esta bien?. Solo pudimos agregar los pops de esta forma.

Como esta forma no nos convencia. 
Pensamos que quizas habría una forma de patear el problema de generar el código de los pushs y pop
de los argumentos que van a memoria, para más adelante, en el coloreo (como se hace con los MOVEs a
temporarios frescos de los registros calle saves, en procEntryExit1).

- Si r5 y LR con todos los registros calle saves, ¿podemos usar cualquiera de estas dos formas
para retornar a la próxima intrucción de la función llamante?.

  ...
  BL function1
  ...


function1 (Opción 1)
  PUSH  {R5,LR}
  ...
  POP {R5,PC}

function1 (Opción 2)
  PUSH  {R5,LR}
  ...
  POP {R5,LR}
  BX  LR

- ¿Tenemos que hacer una arista "de vuelta", entre el último nodo del flujo del body de una función f y el nodo sucesor del nodo que represental al call f?.
  Si es necesario, ¿como podemos hacerla?.

- ¿Es necesario hacer un nodo para cada una de las instr de assembler o solo para las OPER?

- ¿Cómo podemos probar las cosas relacionadas con los grafos?

- En la función munchStm, cuando procesa un CALL (NAME name, ...), el datatype que generamos es un OPER, donde fijamos "jump = SOME [name]", 
pero en el libro esta como "jump = NONE" . ¿Cuál es la correcta?.

- A la hora de crear el grafo de flujo, sabemos que si llegamos a una instrucción X con un jump a Y, tenemos que crear una arista entre el
nodo X y el nodo de la proxima instrucción a Y. Pero, ¿qué pasa si la instrucción se corresponde a un CJUMP?. Creemos que en este caso deberiamos
hacer no solo la arista a la proxima instrucción del label, sino tambien una arista entre la proxima instrucción al CJUMP.

- Nosotros generamos una instrucción utilizando el constructor MOVE solo cuando se transfiere datos de un temporario a otro.
¿Así está bien?

- ¿Podemos llenar el campo "dst" de una instrucción, tanto en la función muchExp como muchStm?
Por ejemplo, queremos hacer:
munchStm (T.MOVE (TEMP i) e2) = emit (MOVE {src = [muchExp e2], dst=[i], ..})
¿Está bien?. 
Nosotros creiamos que como un statement no devuelve un valor, no debia utilizarse el campo "dst" de la instrucción asociada.


--------------------------------------------------------------------------------
Dudas NO resueltas 2017

- En el chequeo de tipos, ¿deberiamos capturar la excepción Ciclo, y mostrar un error más detallado?.

- ¿Esta bien mantener dos levels donde el nombre del frame sea "_tigermain", en la pila de levels (uno viene por defecto, al crear la pila)?.

- ¿Podemos definir en tiger una función de nombre "_tigermain"?.

- A nosotros no nos importa el orden con el cual se declaran los miembros de un record, está bien?. Según la pág. 518 del libro, SI importa.

- ¿Por qué la alocación de un record en memoria ocurre en el orden inverso al declarado? (No hay problema al recorrerlo, sólo nos llama la atención
  que se haga todo en orden inverso)


Selección de instrucciones y Livennes
-------------------------------------

- En el caso "EXP e" de munchStm consideramos que la instrucción generada es vacia (el campo assem = ""), ¿Está bien? ¿Es necesario este caso?

- ¿Como deberíamos implementar procEntryExit2?. A que se refiere con: "indica al register allocator que ciertos registros se mantienen vivos 
  en la salida de la función".

- Está bien hacer que los campos "use" y "def" de un grafo de flujo, sean conjuntos (en el libro, son listas)?.

- En el libro, páginas 225 y 226, plantea un caso particular en el que puede definirse una variable que luego no se utiliza. Menciona que
  interfiere con aquellas variable cuyo rango de vida que se solape con el rango de vida de esta variable (rango nulo).
  ¿Me podrías plantear un caso en el que se dé esta situación?
  ¿Como deberíamos tratarlo, si es necesario?

- Nosotros calculamos los liveouts para cada instrucción (liveMap), pero en la función Build (del pseudo-código de coloreo) inicia calculando los liveouts de un bloque 
de instrucciones, "liveOut (bloque)", y lo guarda en una variable llamada "live". ¿A qué se refiere "liveOut(bloque)" ?.
Creemos que serían los temporarios que quedan vivos al finalizar el bloque. Ya que en el libro no explica como se calcula, ¿podemos adaptar el pseudo-código para usar liveMap?.

- Una de las sentencias de Build agrega a la variable "live" los def(Instr), esto provoca que luego se generen bucles en el grafo de interferencias sobre los nodos que se corresponden a los temporarios de def. ¿Esta bien que suceda ésto?.


 Coloreo
 --------

- En la función "simpleregalloc", la variable "precolored", ¿se refiere a los registros de la arquitectura?. 
 ¿A qué se refiere la variable "asignables"? ¿Son aquellos registros que se pueden utilizar para colorear?.
 ¿La cantidad de colores K sería la cantidad de registros asignables?.

- La función "simpleregalloc" que está en el archivo tigersimpleregalloc.sml (en entrega3, lo adjunto), hace un coloreo y reescritura de la instrucciones "básico", ¿verdad?.
 Vale la pena que lo adaptemos a nuestra arquitectura para ir probando lo que hicimos, antes de terminar de implementar el coloreo recomendado en el libro?.

- ¿Los registros "asignables" son los registros de propósito general?. En nuestro caso tenemos:
Total de registros = ["r0","r1","r2","r3","r4","r5","r6","r7","r8","r9","r10",lr,fp, sp, pc]
Asignables = ["r4","r5","r6","r7","r8","r9","r10"]

Nosotros excluimos de los registros asignables aquellos que tienen un proposito especifico, por ejemplo r0 es el valor de retorno o el primer arg.
En caso de no ser correcto el razonamiento anterior, ¿Qué razonamiento debemos seguir para encontrar los registros asignables?



LO ÚLTIMO:
- Adaptar el coloreo echo por Guido.
- Probar un ejemplo en la máquina virtualizada.


LO HECHO:
- Funciona el intérprete agregandole el prefijo a los labels de funciones.
- Modificamos el interprete para que respete el allocArray de C.
- Arreglado el almacenamiento de strings en el interprete.
- Modificamos getstrFun para que tome de a un char (antes tomaba toda una línea y por esto no funcionaba el ejemplo del merge).
- Testeado el array.
- Seteado correctamente los registros fv, sp, etc.
- Controlamos todos los test usando el intérprete.
- Terminar llamada a función para assembler en tigercodegen.sml.
- Hecho caso para el NAME en munchExp (puede llegar este caso cuando hay una string).
- Hechos los casos de BINOP para las demás operaciones (MINUS, MUL, DIV, etc.).
- Agregar los casos de error para tener los matching completos del munch.
- Terminada función "format" de codegen.sml.
- Arreglar munchArgs. Guardar correctamente los argumentos que van a memoria (usar push).
- Terminar el código que guarda y restaura los callee saves. Arreglar el ejemplo "testMultipleArgs.tig".
- Terminado selección de instruciones.
- Terminado tigergraph.sml
- Haciendo del gráfico de interferencias.


OBSERVACIÓN
- Tener en cuenta que la instrucción "bl" requiere agregar dos instrucciones al término del body de la función a la que se salta.